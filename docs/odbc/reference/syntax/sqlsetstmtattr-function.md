---
title: "Função SQLSetStmtAttr | Microsoft Docs"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname: SQLSetStmtAttr
apilocation: sqlsrv32.dll
apitype: dllExport
f1_keywords: SQLSetStmtAttr
helpviewer_keywords: SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
caps.latest.revision: "32"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: be7fb7064f3e6508b481011ed2aa05068542cef9
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/21/2017
---
# <a name="sqlsetstmtattr-function"></a>Função SQLSetStmtAttr
**Conformidade**  
 Versão introduzidas: Conformidade de padrões 3.0 ODBC: 92 ISO  
  
 **Resumo**  
 **SQLSetStmtAttr** define atributos relacionados a uma instrução.  
  
> [!NOTE]  
>  Para obter mais informações sobre o que o Gerenciador de Driver mapeia essa função quando um ODBC 3*. x* aplicativo estiver trabalhando com um ODBC 2*. x* driver, consulte [mapeamento de funções de substituição para recuar Compatibilidade de aplicativos](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxe  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 [Entrada] Identificador de instrução.  
  
 *Atributo*  
 [Entrada] Opção de definir, listadas em "Comentários".  
  
 *ValuePtr*  
 [Entrada] Valor a ser associado aos *atributo*. Dependendo do valor de *atributo*, *ValuePtr* será um dos seguintes:  
  
-   Um indicador de descritor ODBC.  
  
-   Um valor SQLUINTEGER.  
  
-   Um valor SQLULEN.  
  
-   Um ponteiro para um dos seguintes:  
  
    -   Uma cadeia de caracteres terminada em nulo.  
  
    -   Um buffer de binário.  
  
    -   Um valor ou uma matriz do tipo SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Um valor definido pelo driver.  
  
 Se o *atributo* argumento é um valor específico do driver, *ValuePtr* pode ser um inteiro com sinal.  
  
 *StringLength*  
 [Entrada] Se *atributo* é um atributo definido pelo ODBC e *ValuePtr* aponta para uma cadeia de caracteres ou um buffer binário, este argumento deve ser o comprimento de \* *ValuePtr*. Se *atributo* é um atributo definido pelo ODBC e *ValuePtr* é um inteiro, *StringLength* será ignorado.  
  
 Se *atributo* é um atributo definido pelo driver, o aplicativo indica a natureza do atributo para o Gerenciador de Driver, definindo o *StringLength* argumento. *StringLength* pode ter os seguintes valores:  
  
-   Se *ValuePtr* é um ponteiro para uma cadeia de caracteres, em seguida, *StringLength* é o comprimento da cadeia de caracteres ou SQL_NTS.  
  
-   Se *ValuePtr* é um ponteiro para um buffer de binário, em seguida, o aplicativo coloca o resultado da SQL_LEN_BINARY_ATTR (*comprimento*) macro em *StringLength*. Isso coloca um valor negativo em *StringLength*.  
  
-   Se *ValuePtr* é um ponteiro para um valor diferente de uma cadeia de caracteres ou uma cadeia de caracteres binária, em seguida, *StringLength* devem ter o valor SQL_IS_POINTER.  
  
-   Se *ValuePtr* contém um valor de comprimento fixo, em seguida, *StringLength* é SQL_IS_INTEGER ou SQL_IS_UINTEGER, conforme apropriado.  
  
## <a name="returns"></a>Retorna  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>diagnóstico  
 Quando **SQLSetStmtAttr** retorna SQL_ERROR ou SQL_SUCCESS_WITH_INFO, um valor SQLSTATE associado pode ser obtida chamando **SQLGetDiagRec** com um *HandleType* do SQL _HANDLE_STMT e um *tratar* de *StatementHandle*. A tabela a seguir lista os valores SQLSTATE normalmente retornados por **SQLSetStmtAttr** e explica cada uma no contexto dessa função; a notação "(DM)" precede as descrições de SQLSTATEs retornados pelo Gerenciador de Driver. O código de retorno associado a cada valor SQLSTATE é SQL_ERROR, a menos que indicado em contrário.  
  
|SQLSTATE|Erro|Description|  
|--------------|-----------|-----------------|  
|01000|Aviso geral|Mensagem de informação específica do driver. (A função retornará SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valor de opção alterado|O driver não oferecia suporte ao valor especificado em *ValuePtr*, ou o valor especificado em *ValuePtr* era inválido devido a condições de trabalho de implementação para o driver substituído um valor semelhante. (**SQLGetStmtAttr** pode ser chamado para determinar o valor substituído temporariamente.) O valor de substituição é válido para o *StatementHandle* até que o cursor seja fechado, no ponto em que o atributo de instrução será revertido para seu valor anterior. Os atributos de instrução que podem ser alterados são:<br /><br /> SQL _ ATTR_CONCURRENCY SQL _ ATTR_CURSOR_TYPE SQL _ ATTR_KEYSET_SIZE SQL _ ATTR_MAX_LENGTH SQL _ ATTR_MAX_ROWS SQL _ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL _ ATTR_SIMULATE_CURSOR<br /><br /> (A função retornará SQL_SUCCESS_WITH_INFO.)|  
|08S01|Falha de link de comunicação|Falha do link de comunicação entre o driver e a fonte de dados ao qual o driver foi conectado antes do processamento da função foi concluída.|  
|24000|Estado de cursor inválido|O *atributo* foi SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS e o cursor estava aberto.|  
|HY000|Erro geral|Ocorreu um erro para o qual não houve nenhuma SQLSTATE específico e para o qual nenhuma SQLSTATE específicos de implementação foi definida. A mensagem de erro retornada pelo **SQLGetDiagRec** no  *\*MessageText* buffer descreve o erro e sua causa.|  
|HY001|Erro de alocação de memória|O driver não pôde alocar a memória necessária para dar suporte a execução ou a conclusão da função.|  
|HY009|Uso inválido de ponteiro nulo|O *atributo* argumento identificado um atributo de instrução que é necessário um atributo de cadeia de caracteres, e o *ValuePtr* argumento era um ponteiro nulo.|  
|HY010|Erro de sequência de função|(DM) uma função de execução assíncrona foi chamada para o identificador de conexão que está associado a *StatementHandle*. Essa função assíncrona ainda estava em execução quando o **SQLSetStmtAttr** função foi chamada.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, ou **SQLMoreResults** foi chamado para o *StatementHandle* e retornado SQL_PARAM_DATA_ DISPONÍVEL. Essa função foi chamada antes de recuperação para todos os parâmetros de fluxo de dados.<br /><br /> (DM) uma função de execução assíncrona foi chamada para o *StatementHandle* e ainda estava em execução quando esta função foi chamada.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, ou **SQLSetPos** foi chamado para o  *StatementHandle* e retorna SQL_NEED_DATA. Essa função foi chamada antes de dados foi enviados para todas as colunas ou parâmetros de dados em execução.|  
|HY011|Atributo não pode ser definido agora|O *atributo* foi SQL_ATTR_CONCURRENCY, SQL _ ATTR_CURSOR_TYPE, SQL _ ATTR_SIMULATE_CURSOR ou ATTR_USE_BOOKMARKS SQL _ e a instrução foi preparada.|  
|HY013|Erro de gerenciamento de memória|Não foi possível processar a chamada de função porque os objetos de memória subjacente não podem ser acessados, possivelmente devido a condições de memória insuficiente.|  
|HY017|Uso inválido de um indicador de descritor alocado automaticamente|(DM) a *atributo* argumento era SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) a *atributo* argumento era SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC e o valor do *ValuePtr* era um indicador de descritor alocado implicitamente que não seja o identificador originalmente alocada para a descartar ou APD.|  
|HY024|Valor de atributo inválido|Dado especificado *atributo* valor, um valor inválido foi especificado na *ValuePtr*. (O Gerenciador de Driver retorna esse SQLSTATE apenas para a conexão e os atributos de instrução que aceitam um conjunto separado de valores, como SQL_ATTR_ACCESS_MODE ou ATTR_ASYNC_ENABLE SQL _. Para todos os outros conexão e atributos de instrução, o driver deve verificar o valor especificado em *ValuePtr*.)<br /><br /> O *atributo* argumento era SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, e *ValuePtr* era um identificador de descritor alocado explicitamente que não está na mesma conexão como o  *StatementHandle* argumento.|  
|HY090|Comprimento de buffer ou cadeia de caracteres inválido|(DM)  *\*ValuePtr* é uma cadeia de caracteres e o *StringLength* argumento era menor que 0 mas não estavam SQL_NTS.|  
|HY092|Identificador de atributo/opção inválido|(DM) o valor especificado para o argumento *atributo* não era válido para a versão do ODBC com suporte pelo driver.<br /><br /> (DM) o valor especificado para o argumento *atributo* era um atributo somente leitura.|  
|HY117|Conexão está suspenso devido ao estado de transação desconhecido. Somente Desconecte e funções de somente leitura são permitidas.|(DM) para obter mais informações sobre o estado suspenso, consulte [função SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Recurso opcional não implementado|O valor especificado para o argumento *atributo* era um atributo de instrução ODBC válido para a versão do ODBC com suporte pelo driver, mas não era compatível com o driver.<br /><br /> O *atributo* argumento era SQL_ATTR_ASYNC_ENABLE e uma chamada para **SQLGetInfo** com um *informação* de SQL_ASYNC_MODE retorna SQL_AM_CONNECTION.<br /><br /> O *atributo* argumento SQL_ATTR_ENABLE_AUTO_IPD, e o valor do atributo de conexão SQL_ATTR_AUTO_IPD era SQL_FALSE.|  
|HYT01|Tempo limite de Conexão expirou|O período de tempo limite de conexão expirou antes que a fonte de dados respondeu à solicitação. O período de tempo limite de conexão é definido por meio de **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Driver não dá suporte a esta função|O driver em (DM) associado a *StatementHandle* não oferece suporte para a função.|  
|S1118|Driver não dá suporte a notificação assíncrona|Se chamar **SQLSetStmtAttr** definir SQL_ATTR_ASYNC_STMT_EVENT; não há suporte para a notificação assíncrona pelo driver.|  
  
## <a name="comments"></a>Comentários  
 Atributos de instrução para uma instrução permanecerão em vigor até que sejam alteradas por outra chamada para **SQLSetStmtAttr** ou até que a instrução será descartada chamando **SQLFreeHandle**. Chamando **SQLFreeStmt** com o SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS opção não redefinir atributos de instrução.  
  
 Alguns atributos de instrução oferecem suporte à substituição de um valor semelhante se a fonte de dados não dá suporte para o valor especificado em *ValuePtr*. Nesses casos, o driver retorna SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (valor da opção alterado). Por exemplo, se *atributo* é SQL_ATTR_CONCURRENCY e *ValuePtr* é SQL_CONCUR_ROWVER, e se a fonte de dados não der suporte a isso, o driver substitui SQL_CONCUR_VALUES e retorna SQL _ SUCCESS_WITH_INFO. Para determinar o valor substituído, um aplicativo chama **SQLGetStmtAttr**.  
  
 Definir o formato das informações com *ValuePtr* depende especificado *atributo*. **SQLSetStmtAttr** aceita informações de atributo em um dos dois formatos diferentes: uma cadeia de caracteres ou um valor inteiro. O formato de cada um é indicado na descrição do atributo. Esse formato se aplica às informações retornadas para cada atributo em **SQLGetStmtAttr**. Apontada por cadeias de caracteres de *ValuePtr* argumento de **SQLSetStmtAttr** ter um comprimento de *StringLength*.  
  
> [!NOTE]  
>  A capacidade de definir atributos de instrução no nível de conexão chamando **SQLSetConnectAttr** foi preterido no ODBC 3*. x*. ODBC 3*. x* aplicativos nunca devem definir atributos de instrução no nível de conexão. ODBC 3*. x* atributos de instrução não podem ser definidos no nível de conexão, com exceção dos atributos SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, que são atributos de conexão e atributos de instrução e pode ser definir o nível de conexão ou o nível de instrução.  
  
> [!NOTE]  
>  ODBC 3*. x* drivers necessitam suporte para essa funcionalidade somente se eles devem funcionar com ODBC 2*. x* aplicativos que definam o ODBC 2*. x* opções da instrução no nível de conexão. Para obter mais informações, consulte "Configuração instrução opções sobre a Conexão nível em" [SQLSetConnectOption mapeamento](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) no Apêndice g: Driver diretrizes para compatibilidade com versões anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrução que definem campos de descritor  
 Muitos atributos de instrução correspondem a um campo de cabeçalho de um descritor. Definir esses atributos realmente resultará na configuração dos campos de descritor. Definindo campos por uma chamada para **SQLSetStmtAttr** em vez de para **SQLSetDescField** tem a vantagem de um identificador do descritor não precisa ser obtido para a chamada de função.  
  
> [!CAUTION]  
>  Chamando **SQLSetStmtAttr** para uma instrução pode afetar outras instruções. Isso ocorre quando o APD ou descartar associados à instrução explicitamente é alocado e também está associado com outras instruções. Porque **SQLSetStmtAttr** modifica o APD ou descartar, as modificações se aplicam a todas as instruções ao qual esse descritor está associado. Se isso não é o comportamento necessário, o aplicativo deve desassociar este descritor de outras instruções (chamando **SQLSetStmtAttr** para definir o campo SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC para outro Identificador do descritor) antes de chamar **SQLSetStmtAttr** novamente.  
  
 Quando um campo de descritor é definido como resultado do atributo de instrução correspondente que está sendo definido, o campo é definido somente para os descritores de aplicável que estão atualmente associados com a instrução identificada pelo *StatementHandle* argumento e a configuração do atributo não afeta qualquer descritores que podem ser associados essa instrução no futuro. Quando um campo de descritor que também é um atributo de instrução é definido por uma chamada para **SQLSetDescField**, o atributo de instrução correspondente é definido. Se um descritor alocado explicitamente é separado de uma instrução, um atributo de instrução que corresponde a um campo de cabeçalho será revertido para o valor do campo de descritor alocado implicitamente.  
  
 Quando uma instrução é alocada (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatro identificadores de descritor são alocados automaticamente e associadas à instrução. Identificadores de descritor alocado explicitamente podem ser associados à instrução chamando **SQLAllocHandle** com um *fHandleType* de SQL_HANDLE_DESC para alocar um identificador do descritor e, em seguida, chamar  **SQLSetStmtAttr** para associar o identificador do descritor de instrução.  
  
 Os atributos de instrução na tabela a seguir correspondem aos campos de cabeçalho do descritor.  
  
|Atributo de instrução|Campo de cabeçalho|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|DESCARTAR|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|DESCARTAR|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|DESCARTAR|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|DESCARTAR|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Atributos de instrução  
 Os atributos definidos atualmente e a versão do ODBC no qual eles foram apresentados são mostrados na tabela a seguir; é esperado que serão definidos atributos mais drivers para tirar proveito de diferentes fontes de dados. Um intervalo de atributos é reservado pelo ODBC; os desenvolvedores de driver devem reservar valores para seu próprio uso específico do driver do Open Group. Para obter mais informações, consulte [tipos de dados específicos do Driver, tipos de descritor, tipos de informações, tipos de diagnóstico e atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|*ValuePtr* conteúdo|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|O identificador para o APD para chamadas subsequentes para **SQLExecute** e **SQLExecDirect** no identificador da instrução. O valor inicial deste atributo é o descritor alocado implicitamente quando a instrução foi inicialmente alocada. Se o valor desse atributo é definido como SQL_NULL_DESC ou o identificador originalmente alocado para o descritor de, um identificador APD explicitamente alocado que foi previamente associado com o identificador de instrução é dissociado dele e o identificador de instrução é revertida para o alocado implicitamente identificador APD.<br /><br /> Esse atributo não pode ser definido para um indicador de descritor que foi alocado implicitamente para outra instrução ou outro identificador do descritor que foi implicitamente definido na mesma instrução; identificadores de descritor alocado implicitamente não podem ser associados a mais de uma instrução ou o identificador do descritor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|O identificador para descartar para buscas subsequentes no identificador da instrução. O valor inicial deste atributo é o descritor alocado implicitamente quando a instrução foi inicialmente alocada. Se o valor desse atributo é definido como SQL_NULL_DESC ou o identificador originalmente alocado para o descritor de, um identificador de descartar explicitamente alocado que foi previamente associado com o identificador de instrução é dissociado dele e o identificador de instrução é revertida para o Identificador de descartar foi alocado implicitamente.<br /><br /> Esse atributo não pode ser definido para um indicador de descritor que foi alocado implicitamente para outra instrução ou outro identificador do descritor que foi implicitamente definido na mesma instrução; identificadores de descritor alocado implicitamente não podem ser associados a mais de uma instrução ou o identificador do descritor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Um valor SQLULEN que especifica se uma função chamada com a instrução é executada de forma assíncrona:<br /><br /> SQL_ASYNC_ENABLE_OFF = suporte de nível de execução assíncrona de instrução Disable (o padrão).<br /><br /> SQL_ASYNC_ENABLE_ON = Habilitar suporte de nível de execução assíncrona de instrução.<br /><br /> Para obter mais informações, consulte [execução assíncrona (método de sondagem)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Para os drivers com suporte de nível de execução assíncrona de instrução, o atributo de instrução SQL_ATTR_ASYNC_ENABLE é somente leitura. Seu valor é igual ao valor do atributo de nível de conexão com o mesmo nome no momento em que o identificador de instrução foi alocado.<br /><br /> Chamando **SQLSetStmtAttr** para definir SQL_ATTR_ASYNC_ENABLE quando o SQL_ASYNC_MODE *informação* retornará SQL_AM_CONNECTION retornará SQLSTATE HYC00 (recurso opcional não implementado). Para obter mais informações, consulte [função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obter mais informações.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Um valor SQLPOINTER é um identificador de evento.<br /><br /> Notificação de conclusão de funções assíncronas é ativada chamando **SQLSetStmtAttr** para definir o **SQL_ATTR_ASYNC_STMT_EVENT** de atributos e especificar o identificador de eventos.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Um SQLPOINTER para a função de retorno de chamada assíncrono.<br /><br /> Somente o Gerenciador de Driver pode chamar um driver **SQLSetStmtAttr** função com esse atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Um SQLPOINTER para a estrutura de contexto<br /><br /> Somente o Gerenciador de Driver pode chamar um driver **SQLSetStmtAttr** função com esse atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Um valor SQLULEN que especifica a simultaneidade de cursor:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor é somente leitura. Não são permitidas atualizações.<br /><br /> SQL_CONCUR_LOCK = o Cursor usa o nível mais baixo de bloqueio suficiente para garantir que a linha pode ser atualizada.<br /><br /> SQL_CONCUR_ROWVER = controle de simultaneidade otimista usa Cursor, comparando versões de linha como SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = controle de simultaneidade otimista usa Cursor, comparação de valores.<br /><br /> O valor padrão para SQL_ATTR_CONCURRENCY é SQL_CONCUR_READ_ONLY.<br /><br /> Esse atributo não pode ser especificado para um cursor aberto. Para obter mais informações, consulte [tipos de simultaneidade](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se o SQL_ATTR_CURSOR_TYPE *atributo* é alterado para um tipo que não oferece suporte para o valor atual de SQL_ATTR_CONCURRENCY, o valor de SQL_ATTR_CONCURRENCY será alterado em tempo de execução e um aviso será emitido quando **SQLExecDirect** ou **SQLPrepare** é chamado.<br /><br /> Se o driver dá suporte a **SELECT FOR UPDATE** instrução e tal uma instrução for executada enquanto o valor de SQL_ATTR_CONCURRENCY é definido como SQL_CONCUR_READ_ONLY, um erro será retornado. Se o valor de SQL_ATTR_CONCURRENCY é alterado para um valor que o driver dá suporte para algum valor de SQL_ATTR_CURSOR_TYPE, mas não para o valor atual de SQL_ATTR_CURSOR_TYPE, o valor de SQL_ATTR_CURSOR_TYPE será alterado em tempo de execução e 01S02 SQLSTATE (O valor de opção alterado) é emitido quando **SQLExecDirect** ou **SQLPrepare** é chamado.<br /><br /> Se a simultaneidade especificada não é suportada pela fonte de dados, o driver substitui uma simultaneidade diferente e retornará SQLSTATE 01S02 (valor da opção alterado). Para SQL_CONCUR_VALUES, o driver substitui SQL_CONCUR_ROWVER e vice-versa. Para SQL_CONCUR_LOCK, substitui o driver, em ordem, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. A validade do valor substituído não é verificada até o tempo de execução.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CONCURRENCY e outros atributos de cursor, consulte [características de Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Um valor SQLULEN que especifica o nível de suporte que o aplicativo requer. A configuração desse atributo afeta as chamadas subsequentes para **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = rolável cursores não são necessários no identificador da instrução. Se o aplicativo chama **SQLFetchScroll** neste identificador, o único valor válido de *FetchOrientation* é SQL_FETCH_NEXT. Esse é o padrão.<br /><br /> SQL_SCROLLABLE = rolável cursores são necessários no identificador da instrução. Ao chamar **SQLFetchScroll**, o aplicativo pode especificar qualquer valor válido de *FetchOrientation*, atingir o posicionamento do cursor em modos diferentes de modo sequencial.<br /><br /> Para obter mais informações sobre cursores roláveis, consulte [cursores roláveis](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SCROLLABLE e outros atributos de cursor, consulte [características de Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Um valor SQLULEN que especifica se os cursores no identificador da instrução tornar visíveis as alterações feitas a um resultado definido por outro cursor. A configuração desse atributo afeta as chamadas subsequentes para **SQLExecDirect** e **SQLExecute**. Um aplicativo pode ler novamente o valor deste atributo para obter o estado inicial ou seu estado como mais recentemente definido pelo aplicativo.<br /><br /> SQL_UNSPECIFIED = ele é especificado, o que é o tipo de cursor e se os cursores no identificador da instrução tornar visíveis as alterações feitas em um conjunto de resultados por outro cursor. Cursores no identificador da instrução podem tornar visível none, algumas ou todas essas alterações. Esse é o padrão.<br /><br /> SQL_INSENSITIVE = todos os cursores no identificador de instrução mostrar o conjunto de resultados sem refletir as alterações feitas por qualquer outro cursor. Cursores sem distinção são somente leitura. Isso corresponde a um cursor estático, que tem uma simultaneidade que é somente leitura.<br /><br /> SQL_SENSITIVE = todos os cursores na instrução identificador tornar visível todas as alterações feitas a um resultado definidas por outro cursor.<br /><br /> Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_SENSITIVITY e outros atributos de cursor, consulte [características de Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Um valor SQLULEN que especifica o tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = a cursor somente rola para frente.<br /><br /> SQL_CURSOR_STATIC = os dados no resultado do conjunto é estático.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = a salva de driver e usa as chaves para o número de linhas especificado no atributo de instrução SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = a salva de driver e usa apenas as chaves para as linhas no conjunto de linhas.<br /><br /> O valor padrão é SQL_CURSOR_FORWARD_ONLY. Esse atributo não pode ser especificado após a instrução SQL foi preparada.<br /><br /> Se o tipo de cursor especificado não é suportado pela fonte de dados, o driver substitui um tipo de cursor diferente e retornará SQLSTATE 01S02 (valor da opção alterado). Para um cursor dinâmico ou misto, o driver substitui, em ordem, um cursor controlado por conjunto de chaves ou estático. Para um cursor controlado por conjunto de chaves, o driver substitui um cursor estático.<br /><br /> Para obter mais informações sobre tipos de cursor rolável, consulte [tipos de Cursor rolável](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obter mais informações sobre a relação entre SQL_ATTR_CURSOR_TYPE e outros atributos de cursor, consulte [características de Cursor e tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Um valor SQLULEN que especifica se o preenchimento automático do IPD é executado:<br /><br /> SQL_TRUE = ativa na população automática do IPD após uma chamada para **SQLPrepare**. SQL_FALSE = ativa população automática do IPD após uma chamada para **SQLPrepare**. (Um aplicativo ainda pode obter informações de campo IPD chamando **SQLDescribeParam**, se houver suporte.) O valor padrão do atributo de instrução SQL_ATTR_ENABLE_AUTO_IPD é SQL_FALSE. Para obter mais informações, consulte [preenchimento automático do IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Um SQLLEN \* que aponta para um valor de indicador binário. Quando **SQLFetchScroll** é chamado com *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, o driver assumirá o valor do indicador desse campo. Este campo define como padrão um ponteiro nulo. Para obter mais informações, consulte [rolar pelo indicador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> O valor apontado por este campo não é usado para exclusão pelo indicador, atualize pelo indicador ou buscar por operações de indicador no **SQLBulkOperations**, que usam marcadores armazenados em cache nos buffers de conjunto de linhas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|O identificador para o IPD. O valor desse atributo é o descritor alocado quando a instrução foi inicialmente alocada. O aplicativo não é possível definir esse atributo.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** , mas não é definida por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|O identificador para o IRD. O valor desse atributo é o descritor alocado quando a instrução foi inicialmente alocada. O aplicativo não é possível definir esse atributo.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** , mas não é definida por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Um SQLULEN que especifica o número de linhas no conjunto de chaves para um cursor controlado por conjunto de chaves. Se o tamanho do conjunto de chaves é 0 (o padrão), o cursor é totalmente controlados por conjunto de chaves. Se o tamanho do conjunto de chaves é maior que 0, o cursor é misto (controlado por no conjunto de chaves e dinâmico fora do conjunto de chaves). O tamanho do conjunto de chaves padrão é 0. Para obter mais informações sobre os cursores controlados por conjuntos de chaves, consulte [Keyset-Driven cursores](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Se o tamanho especificado excede o tamanho máximo do conjunto de chaves, o driver substitui esse tamanho e retornará SQLSTATE 01S02 (valor da opção alterado).<br /><br /> **SQLFetch** ou **SQLFetchScroll** retornará um erro se o tamanho do conjunto de chaves é maior que 0 e menor que o tamanho do conjunto de linhas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Um valor SQLULEN que especifica a quantidade máxima de dados que o driver retorna de um caractere ou uma coluna binária. Se *ValuePtr* é menor que o comprimento dos dados disponíveis, **SQLFetch** ou **SQLGetData** truncará os dados e retorna SQL_SUCCESS. Se *ValuePtr* é 0 (o padrão), o driver tenta retornar todos os dados disponíveis.<br /><br /> Se o comprimento especificado é menor que a quantidade mínima de dados que pode retornar a fonte de dados ou maior que a quantidade máxima de dados que a fonte de dados pode retornar, substitui o driver que valor e retorna um SQLSTATE 01S02 (valor da opção alterado).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; No entanto, a configuração pode não entram em vigor imediatamente, em cujo caso o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinir o atributo para seu valor original.<br /><br /> Esse atributo destina-se para reduzir o tráfego de rede e deve ser suportado apenas quando a fonte de dados (em vez de driver) em um driver de várias camadas pode implementá-la. Esse mecanismo não deve ser usado por aplicativos para truncar os dados; para truncar dados recebidos, um aplicativo deve especificar o comprimento máximo do buffer no *BufferLength* argumento **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Um valor SQLULEN correspondente para o número máximo de linhas a serem retornadas para o aplicativo para um **selecione** instrução. Se \* *ValuePtr* é igual a 0 (o padrão), o driver retornará todas as linhas.<br /><br /> Esse atributo destina-se a reduzir o tráfego de rede. Conceitualmente, ela será aplicada quando o conjunto de resultados é criado e limita o conjunto de resultados para o primeiro *ValuePtr* linhas. Se o número de linhas no conjunto de resultados é maior que *ValuePtr*, o conjunto de resultados é truncado.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos os conjuntos de resultados no *instrução*, inclusive as retornadas por funções de catálogo. SQL_ATTR_MAX_ROWS estabelece um máximo para o valor da contagem de linha do cursor.<br /><br /> Um driver não deve emular o comportamento SQL_ATTR_MAX_ROWS para **SQLFetch** ou **SQLFetchScroll** (se limitações de tamanho do conjunto de resultados não podem ser implementadas na fonte de dados) se ele não pode garantir que sql_attr MAX_ROWS será implementada corretamente.<br /><br /> Ele é definido pelo driver se SQL_ATTR_MAX_ROWS se aplica a instruções que não sejam instruções SELECT (como funções de catálogo).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; No entanto, a configuração pode não entram em vigor imediatamente, em cujo caso o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinir o atributo para seu valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Um valor SQLULEN que determina como são tratados os argumentos de cadeia de caracteres de funções de catálogo.<br /><br /> Se SQL_TRUE, o argumento de cadeia de caracteres de funções de catálogo são tratadas como identificadores. Caso não é significativo. Cadeias de caracteres não delimitados, o driver remove os espaços à direita e a cadeia de caracteres é armazenada em maiusculas. Cadeias de caracteres delimitada, o driver remove espaços à esquerda ou à direita e tem tudo o que está entre os delimitadores literalmente. Se um desses argumentos é definido como um ponteiro nulo, a função retornará SQL_ERROR e SQLSTATE HY009 (uso inválido de ponteiro nulo).<br /><br /> Se SQL_FALSE, os argumentos de cadeia de caracteres de funções de catálogo não são tratadas como identificadores. O caso é significativo. Eles podem conter um padrão de pesquisa de cadeia de caracteres ou não, dependendo do argumento.<br /><br /> O valor padrão é SQL_FALSE.<br /><br /> O *TableType* argumento de **SQLTables**, que usa uma lista de valores, não é afetado por esse atributo.<br /><br /> SQL_ATTR_METADATA_ID também podem ser definidas no nível de conexão. (Ele e SQL_ATTR_ASYNC_ENABLE são os atributos de instrução única que também são atributos de conexão).<br /><br /> Para obter mais informações, consulte [argumentos em funções de catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Um valor SQLULEN que indica se o driver deve verificar as cadeias de caracteres SQL para sequências de escape:<br /><br /> SQL_NOSCAN_OFF = as verificações de driver cadeias de caracteres SQL para sequências de escape (o padrão).<br /><br /> SQL_NOSCAN_ON = o driver não verifica cadeias de caracteres SQL para sequências de escape. Em vez disso, o driver envia a instrução diretamente à fonte de dados.<br /><br /> Para obter mais informações, consulte [sequências de Escape no ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Um SQLULEN * valor que aponta para um deslocamento adicionado para ponteiros para alterar a associação de parâmetros dinâmicos. Se este campo for não nulo, o driver cancelará o ponteiro, adicionará o valor cancelado a cada um dos campos adiados no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa os novos valores de ponteiro ao fazer a associação. Ele é definido como nulo por padrão.<br /><br /> O deslocamento de ligação sempre é adicionado diretamente para os campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se o deslocamento for alterado para um valor diferente, o novo valor é adicionado diretamente para o valor do campo do descritor. O novo deslocamento não é adicionado para o valor de campo mais qualquer deslocamentos anteriores.<br /><br /> Para obter mais informações, consulte [deslocamentos de associação de parâmetro](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Um valor SQLULEN que indica a orientação de associação a ser usado para parâmetros dinâmicos.<br /><br /> Este campo é definido como SQL_PARAM_BIND_BY_COLUMN (o padrão) para selecionar a associação.<br /><br /> Para selecionar a associação, este campo é definido como o comprimento da estrutura ou uma instância de um buffer que será associada a um conjunto de parâmetros dinâmicos. Esse comprimento deve incluir espaço para todos os parâmetros associados e qualquer preenchimento da estrutura ou do buffer para garantir que, quando o endereço de um parâmetro associado é incrementado com o comprimento especificado, o resultado apontará para o início do mesmo parâmetro no próximo conjunto de parâmetros. Ao usar o *sizeof* operador em ANSI C, esse comportamento é garantido.<br /><br /> Para obter mais informações, consulte [associação matrizes de parâmetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> A configuração desse atributo de instrução define o campo de SQL_DESC_ BIND_TYPE no cabeçalho de APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de valores SQLUSMALLINT usado para ignorar um parâmetro durante a execução de uma instrução SQL. Cada valor é definido como SQL_PARAM_PROCEED (para o parâmetro a ser executado) ou SQL_PARAM_IGNORE (para o parâmetro a ser ignorado).<br /><br /> Um conjunto de parâmetros pode ser ignorado durante o processamento, definindo o valor de status na matriz apontada pelo SQL_DESC_ARRAY_STATUS_PTR no APD para SQL_PARAM_IGNORE. Um conjunto de parâmetros é processado se seu valor de status é definido como SQL_PARAM_PROCEED ou se nenhum elemento na matriz é definido.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retornar parâmetro valores de status. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLExecDirect** ou **SQLExecute** é chamado.<br /><br /> Esse atributo é ignorado quando não há nenhum parâmetro associadas.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de SQLUSMALLINT valores contendo informações de status para cada linha de valores de parâmetro após uma chamada para **SQLExecute** ou **SQLExecDirect**. Esse campo é obrigatório apenas se PARAMSET_SIZE for maior que 1.<br /><br /> Os valores de status podem conter os seguintes valores:<br /><br /> SQL_PARAM_SUCCESS: A instrução SQL foi executada com êxito para esse conjunto de parâmetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: A instrução SQL foi executada com êxito para esse conjunto de parâmetros. No entanto, informações de aviso estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_ERROR: Houve um erro ao processar este conjunto de parâmetros. Informações de erro adicionais estão disponíveis na estrutura de dados de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: Este conjunto de parâmetros foi não utilizado, possivelmente devido ao fato de que um conjunto de parâmetros anteriores causou um erro que foram anuladas processamento adicional ou SQL_PARAM_IGNORE foi definida para esse conjunto de parâmetros na matriz especificada pelo SQL_ATTR_PARAM_ OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: O driver trata as matrizes de parâmetros como uma unidade monolítica e portanto não gera esse nível de informações de erro.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retornar parâmetro valores de status. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLExecute** ou **SQLExecDirect** é chamado. Observe que a configuração deste atributo pode afetar o comportamento de parâmetro de saída implementado pelo driver.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Um SQLULEN \* campos de registro que aponta para um buffer no qual retornar o número de conjuntos de parâmetros que foram processados, incluindo conjuntos de erro. Nenhum número será retornado se esse for um ponteiro nulo.<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho IPD.<br /><br /> Se a chamada para **SQLExecDirect** ou **SQLExecute** que preenche o buffer apontado por este atributo não retorna SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer é indefinido.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Um valor SQLULEN que especifica o número de valores para cada parâmetro. Se SQL_ATTR_PARAMSET_SIZE for maior que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR do ponto de APD a matrizes. A cardinalidade de cada matriz é igual ao valor do campo.<br /><br /> Esse atributo é ignorado quando não há nenhum parâmetro associadas.<br /><br /> Para obter mais informações, consulte [usando matrizes de parâmetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ARRAY_SIZE no cabeçalho APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Um valor SQLULEN correspondente ao número de segundos de espera de uma instrução SQL executar antes de retornar ao aplicativo. Se *ValuePtr* é igual a 0 (padrão), não há nenhum tempo limite.<br /><br /> Se o tempo limite especificado excede o máximo de tempo limite da fonte de dados ou é menor do que o tempo limite mínimo, **SQLSetStmtAttr** substitui esse valor e retorna um SQLSTATE 01S02 (valor da opção alterado).<br /><br /> Observe que o aplicativo não precisa chamar **SQLCloseCursor** reutilizar a instrução se um **selecione** instrução atingiu o tempo limite.<br /><br /> O tempo limite da consulta definido no atributo instrução é válido em modos síncronos e assíncronos.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Um valor SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, em ODBC 3*. x*, **SQLFetch** recuperar dados depois que ele posiciona o cursor para o local especificado. Esse é o padrão.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, em ODBC 3*. x*, **SQLFetch** não recuperar os dados depois que ele posiciona o cursor.<br /><br /> Definindo SQL_RETRIEVE_DATA para SQL_RD_OFF, um aplicativo pode verificar se uma linha existe ou recuperar um indicador para a linha sem incorrer na sobrecarga de recuperar linhas. Para obter mais informações, consulte [rolagem e busca linhas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> O valor desse atributo pode ser definido em um cursor aberto; No entanto, a configuração pode não entram em vigor imediatamente, em cujo caso o driver retornará SQLSTATE 01S02 (valor da opção alterado) e redefinir o atributo para seu valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Um valor SQLULEN que especifica o número de linhas retornadas por cada chamada para **SQLFetch** ou **SQLFetchScroll**. Também é o número de linhas em uma matriz de indicador usado em uma operação de indicador em massa de **SQLBulkOperations**. O valor padrão é 1.<br /><br /> Se o tamanho do conjunto de linhas especificado excede o tamanho máximo de linhas suportado pela fonte de dados, o driver substitui esse valor e retornará SQLSTATE 01S02 (valor da opção alterado).<br /><br /> Para obter mais informações, consulte [tamanho do conjunto de linhas](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ARRAY_SIZE no cabeçalho descartar.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Um SQLULEN * valor que aponta para um deslocamento adicionado para ponteiros para alterar a associação de dados de coluna. Se este campo for não nulo, o driver cancelará o ponteiro, adicionará o valor cancelado a cada um dos campos adiados no registro do descritor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa os novos valores de ponteiro ao fazer a associação. Ele é definido como nulo por padrão.<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_BIND_OFFSET_PTR no cabeçalho descartar.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Um valor SQLULEN que define a orientação de associação a ser usado quando **SQLFetch** ou **SQLFetchScroll** é chamado na instrução associada. A associação é selecionada, definindo o valor como SQL_BIND_BY_COLUMN. A associação é selecionada, definindo o valor para o comprimento de uma estrutura ou uma instância de um buffer no qual as colunas de resultado serão associadas.<br /><br /> Se for especificado um comprimento, ele deve incluir espaço para todas as colunas associadas e qualquer preenchimento da estrutura ou do buffer para garantir que, quando o endereço de uma coluna associada for incrementado com o comprimento especificado, o resultado apontará para o início da mesma coluna th próxima linha de e. Ao usar o **sizeof** operador com estruturas ou uniões em ANSI C, esse comportamento é garantido.<br /><br /> A associação é a orientação de associação padrão para **SQLFetch** e **SQLFetchScroll**.<br /><br /> Para obter mais informações, consulte [colunas de associação para uso com cursores em bloco](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_BIND_TYPE no cabeçalho descartar.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Um valor SQLULEN é o número da linha atual em todo o resultado definido. Se o número da linha atual não pode ser determinado ou se não há nenhuma linha atual, o driver retornará 0.<br /><br /> Esse atributo pode ser recuperado por uma chamada para **SQLGetStmtAttr** , mas não é definida por uma chamada para **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de valores SQLUSMALLINT usado para ignorar uma linha durante uma operação em massa usando **SQLSetPos**. Cada valor é definido como SQL_ROW_PROCEED (para a linha a ser incluído na operação em massa) ou SQL_ROW_IGNORE (para a linha a ser excluído da operação em massa). (Linhas não podem ser ignoradas usando essa matriz durante as chamadas **SQLBulkOperations**.)<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retorna valores de status de linha. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLSetPos** é chamado.<br /><br /> Para obter mais informações, consulte [atualizando linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) e [excluir linhas no conjunto de linhas com SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR na descartar.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Um SQLUSMALLINT \* valor que aponta para uma matriz de SQLUSMALLINT valores que contêm valores de status de linha após uma chamada para **SQLFetch** ou **SQLFetchScroll**. A matriz tem elementos existem linhas no conjunto de linhas.<br /><br /> Esse atributo de instrução pode ser definido como um ponteiro nulo, nesse caso o driver não retorna valores de status de linha. Esse atributo pode ser definido a qualquer momento, mas o novo valor não é usado até a próxima vez **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, ou  **SQLSetPos** é chamado.<br /><br /> Para obter mais informações, consulte [Status e o número de linhas buscadas](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ARRAY_STATUS_PTR no cabeçalho do IRD.<br /><br /> Esse atributo é mapeado por um ODBC 2*. x* driver para o *rgbRowStatus* matriz em uma chamada para **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Um SQLULEN \* valor que aponta para um buffer no qual retornar o número de linhas buscadas após uma chamada para **SQLFetch** ou **SQLFetchScroll**; o número de linhas afetadas por uma operação em massa executada por uma chamada para **SQLSetPos** com um *operação* SQL_REFRESH; ou o número de linhas afetadas por uma operação em massa executada pelo argumento **SQLBulkOperations**. Esse número inclui linhas de erro.<br /><br /> Para obter mais informações, consulte [Status e o número de linhas buscadas](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> A configuração desse atributo de instrução define o campo SQL_DESC_ROWS_PROCESSED_PTR no cabeçalho do IRD.<br /><br /> Se a chamada para **SQLFetch** ou **SQLFetchScroll** que preenche o buffer apontado por este atributo não retorna SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, o conteúdo do buffer é indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Um valor SQLULEN que especifica se drivers simulam posicionados instruções update e delete garante que essas instruções afetam somente uma única linha.<br /><br /> Para simular atualização posicionada e instruções delete, a maioria dos drivers construir uma pesquisa **atualizar** ou **excluir** instrução que contém um **onde** cláusula que especifica o valor de cada coluna na linha atual. A menos que essas colunas formam uma chave exclusiva, tal afirmação pode afetar a mais de uma linha.<br /><br /> Para garantir que essas instruções afetam somente uma linha, o driver determina as colunas em uma chave exclusiva e adiciona essas colunas para o conjunto de resultados. Se um aplicativo garante que as colunas no conjunto de resultados formam uma chave exclusiva, o driver não é necessário para fazer isso. Isso pode reduzir o tempo de execução.<br /><br /> SQL_SC_NON_UNIQUE = o driver garante que simulados posicionado atualização ou instruções delete afeta somente uma linha; é responsabilidade do aplicativo para fazer isso. Se uma instrução afeta mais de uma linha, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retorna SQLSTATE 01001 (conflito de operação de Cursor).<br /><br /> SQL_SC_TRY_UNIQUE = as tentativas de driver para garantir que simulados posicionado atualização ou exclusão instruções afetam somente uma linha. O driver sempre executa essas instruções, mesmo se eles podem afetar a mais de uma linha, como quando não há nenhuma chave exclusiva. Se uma instrução afeta mais de uma linha, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retorna SQLSTATE 01001 (conflito de operação de Cursor).<br /><br /> SQL_SC_UNIQUE = as garantias de driver que simulados atualização posicionada ou excluir instruções afetam somente uma linha. Se o driver não pode garantir isso para uma determinada instrução, **SQLExecDirect** ou **SQLPrepare** retornará um erro.<br /><br /> Se a fonte de dados fornece SQL nativo oferece suporte a atualização posicionada e instruções delete e o driver não simular cursores, SQL_SUCCESS é retornado quando a solicitação de SQL_SC_UNIQUE para SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO será retornado se SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE é solicitado. Se a fonte de dados fornece o nível SQL_SC_TRY_UNIQUE de suporte e o driver não, SQL_SUCCESS é retornado para SQL_SC_TRY_UNIQUE e SQL_SUCCESS_WITH_INFO será retornado para SQL_SC_NON_UNIQUE.<br /><br /> Se o tipo de simulação de cursor especificado não é suportado pela fonte de dados, o driver substitui um tipo diferente de simulação e retornará SQLSTATE 01S02 (valor da opção alterado). Para SQL_SC_UNIQUE, substitui o driver, em ordem, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Para SQL_SC_TRY_UNIQUE, o driver substitui SQL_SC_NON_UNIQUE.<br /><br /> O padrão é SQL_SC_UNIQUE.<br /><br /> Para obter mais informações, consulte [simulando posicionado instruções Update e excluir](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Um valor SQLULEN que especifica se um aplicativo irá usar indicadores com um cursor:<br /><br /> SQL_UB_OFF = desativado (padrão)<br /><br /> SQL_UB_VARIABLE = um aplicativo irá usar indicadores com um cursor, e o driver fornecem indicadores de comprimento variável se eles têm suporte. SQL_UB_FIXED foi preterido no ODBC 3*. x*. ODBC 3*. x* aplicativos sempre devem usar marcadores de comprimento variável, mesmo ao trabalhar com ODBC 2*. x* drivers (que tem suporte apenas 4 bytes, de comprimento fixo indicadores). Isso ocorre porque um indicador de comprimento fixo é apenas um caso especial de um indicador de comprimento variável. Ao trabalhar com um ODBC 2*. x* driver, o Gerenciador de Driver mapeia SQL_UB_VARIABLE para SQL_UB_FIXED.<br /><br /> Para usar marcadores com um cursor, o aplicativo deve especificar esse atributo com o valor SQL_UB_VARIABLE antes de abrir o cursor.<br /><br /> Para obter mais informações, consulte [recuperando indicadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] essas funções podem ser chamadas de forma assíncrona somente se o descritor é um descritor de implementação, não um descritor de aplicativo.  
  
 Consulte [a associação](../../../odbc/reference/develop-app/column-wise-binding.md) e [a associação](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funções relacionadas  
  
|Para obter informações sobre|Consulte|  
|---------------------------|---------|  
|Cancelando o processamento de instrução|[Função SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retornando a configuração de um atributo de conexão|[Função SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retornando a configuração de um atributo de instrução|[Função SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Definir um atributo de conexão|[Função SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Configuração de um único campo do descritor|[Função SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Consulte Também  
 [Referência de API de ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Arquivos de cabeçalho ODBC](../../../odbc/reference/install/odbc-header-files.md)
